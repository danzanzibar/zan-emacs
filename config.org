#+TITLE: Literate Emacs Configuration
#+AUTHOR: Zan Owsley
#+PROPERTY: header-args :tangle yes

* README
** Keybinding scheme.
My conventions for key bindings:
1. Unless redefining an existing command, only use 'C-c letter ...' for
   new key bindings.
2. Global keybinding should use 'C-c k' prefix followed by an
   mnemonically appropriate letter.
3. Once the final letter is chosen (ex. 'a'), use 'a', 'A', or
   'C-a' (do not use 'C-A') in that order of preference. The most
   popular command should use the most preferential choice.
4. Try to use other 'C-c letter' prefix keys for groups of
   commands to keep many 'C-c letter' key bindings available for
   major-mode bindings. In general, only major-mode specific key
   bindings should utlize many 'C-c letter' bindings.
* Init Setup
** Set lexical-binding for the init file.
#+begin_src emacs-lisp
  ;; -*- lexical-binding: t -*-
#+end_src
** Determine the configuration level based on the environment variable 'EMACS_CONFIG_LEVEL'.
The notion here is that my core computers will have a synchronized drive with files that Emacs manages (agenda, textbooks, work docs, etc.). When I'm on a machine like my mom's, or some server, or a VM on some cloud server that I could temporarily use Emacs in, I may still want some of my configuration but without all the personal data management (which will certainly make the init.el file fail to execute anyway with everything missing). The solution is the have an environment variable 'EMACS_CONFIG_LEVEL' set by the system and default to a minimal setup.
#+begin_src emacs-lisp
  (defconst zanc-config-level
    (let ((config-level (getenv "EMACS_CONFIG_LEVEL")))
      (cond ((string= config-level "full") :full-config)
  	  ((string= config-level "minimal") :min-config)
  	  (t :min-config)))
    "This constant is set when loading Emacs based on the value of the
  environment variable 'EMACS_CONFIG_LEVEL'. It is used to conditionally
  execute some of the init file.")
#+end_src
** Set the custom file.
#+begin_src emacs-lisp
  ;;; Seperate out custom file
  (setq custom-file (locate-user-emacs-file "custom.el"))
  (load custom-file :no-error)
#+end_src
** Set the package repos and refresh if needed.
#+begin_src emacs-lisp
  ;;; Initialize package sources
  (require 'package)
  (setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
  			 ("nongnu" . "https://elpa.nongnu.org/nongnu/")
  			 ("melpa" . "https://melpa.org/packages/")
  			 ("melpa-stable" . "https://stable.melpa.org/packages/")
  			 ("org" . "https://orgmode.org/elpa/")))
  (package-initialize)
  (unless package-archive-contents
   (package-refresh-contents))
#+end_src
* User Function Definitions
** Window Functions
#+begin_src emacs-lisp
  ;;; Side window prefix functions.
  ;;; TODO - make it interactive and assign keybinding.
  (defun zanf-side-window-prefix (side &optional slot width)
    (display-buffer-override-next-command
     `(lambda (buffer alist)
        (setq alist (zanf-side-window-prefix--modify-alist
  		   alist ,side ,slot ,width))
        (cons (display-buffer-in-side-window buffer alist) nil))
     nil "[side-window]")
    (message "Display next command buffer in a side window..."))

  (defun zanf-side-window-prefix--modify-alist (alist side slot width)
    (let ((window-params '((window-parameters . ((no-delete-other-windows . t)))))
  	(side `((side . ,(intern side))))
  	(slot `((slot . ,(or slot 0))))
  	(width `((window-width . ,(or width 80)))))
      (append alist window-params side slot width)))

  ;; A command for toggling default vs custom alist.
  (defun zanf-toggle-user-display-buffer-alist ()
    (interactive)
    (if display-buffer-alist
        (progn
  	(setq display-buffer-alist nil)
  	(message "Using default 'display-buffer-alist'"))
      (setq display-buffer-alist zanv-user-display-buffer-alist)
      (message "Using user-defined 'display-buffer-alist'")))
#+end_src
** Project dired function.
#+begin_src emacs-lisp
  (defun zanf-project-dired ()
    "Opens a 'dired' buffer in a left side window at the project root."
    (interactive)
    (require 'project)
    (display-buffer-in-side-window
     (dired-noselect (project-root (project-current t)))
     '((side . left)
       (slot . -1)
       (window-width . 0.15)
       (window-height . 0.7)
       (window-parameters . ((no-delete-other-windows . t))))))
#+end_src
** Project run function.
#+begin_src emacs-lisp  
  (defvar zanv-run-command ""
    "Used to define a project run command to be passed to the 'compile' command.")

  (defun zanf-project-run ()
    "Runs a 'compile' command using the value of 'zanv-run-command'.

  'zanv-run-command' should be set in a .dir-locals.el file for a givne project."
    (declare (interactive-only compile))
    (interactive)
    (let ((default-directory (project-root (project-current t)))
  	(compilation-buffer-name-function
  	 (or project-compilation-buffer-name-function
               compilation-buffer-name-function))
  	(saved-compile-command compile-command)
  	(compile-command zanv-run-command))
      (call-interactively #'compile)
      (setq compile-command saved-compile-command)))
#+end_src
** Others (needs clean up).
#+begin_src emacs-lisp
  ;;; Insert filename.
  (defun zanf-insert-filename ()
    "Insert filename at point.

  Prompts user to pick a file using the 'find-file' interface. Requires that an
  existing file is chosen. Inserts the full filename (including path) as currently
  shown in the minibuffer."
    (interactive)
    (insert (read-file-name "Which file: " nil nil t nil nil)))


  ;; A function for wiping out the rest of buffer after point.

  (defun zanf-kill-to-end-of-buffer ()
    (interactive)
    (kill-region (point) (point-max)))


  ;; A function and helpers for creating a scratch buffer with a specified
  ;; major mode.

  (defvar zanv-derived-majors ())

  (defun zanf-derived-majors--mapatoms-f (symbol)
    (when (and (apply 'provided-mode-derived-p symbol zanv-derived-majors)
  	     (not (member symbol zanv-derived-majors)))
      (setq mode-found t)
      (add-to-list 'zanv-derived-majors symbol)))

  (defun zanf-derived-majors--get-modes ()
    (let ((mode-found nil))
      (mapatoms 'zanf-derived-majors--mapatoms-f)
      (if mode-found
  	(zanf-derived-majors--get-modes))))

  (defun zanf-derived-majors (&rest modes)
    "Search 'obarray' for derived major modes currently loaded in Emacs.

  Parent modes can be specified, or if none are given, defaults to prog-mode
  and text-mode. Returns a list of found major modes. Also updates variable
  'zanv-derived-majors' with returned list."
    (let ((parent-modes (if modes modes '(prog-mode text-mode))))
      (setq zanv-derived-majors parent-modes)
      (zanf-derived-majors--get-modes)
      (dolist (mode parent-modes zanv-derived-majors)
        (setq zanv-derived-majors (remove mode zanv-derived-majors)))))

  (defun zanf-scratch-buffer--choose-major ()
    (completing-read "Which major mode? (default: python-mode) "
  		   (zanf-derived-majors) nil nil nil nil "python-mode"))

  (defun zanf-scratch-buffer ()
    "Create and switch to a new scratch buffer with the chosen major mode enabled.

  Completion is available for major modes currently loaded in Emacs according to
  the function 'zanf-derived-majors'. If you wish to use a major mode not yet
  loaded, you may specify it anyway (without completion)."
    (interactive)
    (let* ((mode (zanf-scratch-buffer--choose-major))
  	 (scratch-name (format "*%s-scratch*"
  			       (substring mode 0 -5))))
      (get-buffer-create scratch-name)
      (switch-to-buffer scratch-name)
      (funcall (intern-soft mode))))


  ;; Make setting bookmark save bookmarks file.
  (defun zanf-bookmark-set ()
    (interactive)
    (bookmark-set)
    (bookmark-save))


  ;; Ask the user if they want to set a bookmark.
  (defun zanf-prompt-for-bookmark ()
    (let ((prompt (read-from-minibuffer "Save a bookmark? (y/n default: no): "
  				      nil nil nil nil "n")))
      (if (string= prompt "y")
  	(zanf-bookmark-set))))


  ;; File-opening functions.
  (defun zanf-open-file-in-dir (dir-path &optional prompt file-extension)
    "Prompt the user to open a file from a specified directory.

  File names will be completed and a file-extension can be specified to filter
  the results."
    (unless prompt (defvar prompt "Which file: "))
    (let* ((files (directory-files dir-path nil (when file-extension (concat ".*\." file-extension))))
  	 (files (remove "." files))
  	 (files (remove ".." files))
  	 (file-name (completing-read prompt files nil t))
  	 (file-path (concat dir-path file-name)))
      (find-file file-path)))

  (defun zanf-pdf-view-quit ()
    (interactive)
    (zanf-prompt-for-bookmark)
    (quit-window))

  ;; Need full-config for these functions.
  (when (eq zanc-config-level :full-config)
    (defun zanf-open-text ()
      "Prompts the user to open a textbook pdf in 'zanv-texts-dir'.

  Completion is provided for any pdf in the directory."
      (interactive)
      (zanf-open-file-in-dir zanv-texts-dir "Which text? " "pdf"))

    (defun zanf-open-pricelist ()
      "Prompts the user to open a pricelist pdf in 'zanv-pricelists-dir'.

  Completion is provided for any pdf in the directory."
      (interactive)
      (zanf-open-file-in-dir zanv-pricelists-dir "Which pricelist? " "pdf")))
#+end_src
** Org-capture functions (full-config).
#+begin_src emacs-lisp
  (when (eq zanc-config-level :full-config)
    (defun zanf-gen-org-capture-template
        (key name file &optional parent-keys parent-heading timestamp literal-heading)
      (let* ((keys (concat parent-keys key))
  	   (heading (or literal-heading name))
  	   (olp (if parent-heading
  		    (if (listp parent-heading)
  			(append parent-heading (list heading))
  		      (list parent-heading heading))
  		  (list heading)))
  	   (template (if timestamp "* TODO %u %?" "* TODO %?")))
        (list keys name 'entry (append `(file+olp ,file) olp) template)))

    (defun zanf-org-capture-templates--project-default (agenda-file)
      "Returns the base project org-capture-template.

  This contains just one template - the one that lets you add other list
  templates."
      `(("n" "New List" entry (file ,agenda-file)
         "* %^{List name}^%^{Capture key} :%^{tags}:")))

    (defun zanf-org-capture-templates--project-templates (agenda-file)
      "Returns the templates for org-capture for the given AGENDA-FILE."
      (let ((templates (zanf-dynamic-capture-templates agenda-file)))
        (cons (zanf-org-capture-templates--project-default agenda-file)
  	    templates)))


    (defun zanf-dynamic-capture-templates--get-gtd-headings (heading)
      (let (subheadings)
        (org-map-entries
         (lambda ()
  	 (when (string= (org-get-heading t t t t) heading)
  	   (org-map-entries
  	    (lambda ()
  	      (push (substring-no-properties (org-get-heading t t t t))
  		    subheadings))
  	    "LEVEL=2"
  	    'tree)))
         "LEVEL=1" 'agenda)
        (nreverse subheadings)))

    ;; A more general function for files that are composed entirely of dynamically
    ;; generated heading through org-capture.
    (defun zanf-dynamic-capture-templates--get-headings (file)
      (let (headings)
        (org-map-entries
         (lambda ()
  	 (push (substring-no-properties (org-get-heading t t t t)) headings))
         "LEVEL=1" `(,file))
        (nreverse headings)))

    (defun zanf-dynamic-capture-templates (agenda-file &optional parent-heading)
      (let ((headings (if (string= agenda-file zanv-gtd)
  			(zanf-dynamic-capture-templates--get-gtd-headings
  			 parent-heading)
  		      (zanf-dynamic-capture-templates--get-headings agenda-file)))
  	  templates)
        (dolist (heading headings)
  	(let* ((parsed-heading (split-string heading "\\^"))
  	       (name (nth 0 parsed-heading))
  	       (keys (nth 1 parsed-heading)))
  	  (push (zanf-gen-org-capture-template
  		 keys name agenda-file nil parent-heading nil heading)
  		templates)))
        (reverse templates))))

#+end_src
** Org-mode functions (full-config).
#+begin_src emacs-lisp
  (when (eq zanc-config-level :full-config)
    ;; Start of zanf-org-refile-list-item and helpers
    ;; Lets you move a list item as-is to another heading within the same file.

    (defvar zanv-org-refile-last-stored-list-item nil)

    (defun zanf-org-refile-store-list-item ()
      (let ((beg (line-beginning-position))
            (end (line-end-position)))	
        (setq zanv-org-refile-last-stored-list-item (buffer-substring-no-properties beg end))
        (delete-region beg (line-beginning-position 2))))

    (defun zanf-org-refile-choose-heading ()
      (completing-read "Choose a heading: "
  		     (org-map-entries
  		      #'(org-get-heading :no-tags :no-todo :no-cookie :no-comment))))

    (defun zanf-org-refile-find-heading (target-heading)
      (goto-char (point-min))
      (re-search-forward (format "^\\*+\\( .*? \\| \\)%s" target-heading) nil nil 1)
      (goto-char (line-beginning-position))
      (unwind-protect
  	(progn
  	  (org-narrow-to-subtree)
  	  (goto-char (point-max)))
        (widen)))

    (defun zanf-org-refile-list-item ()
      (interactive)
      (let ((target (zanf-org-refile-choose-heading)))
        (zanf-org-refile-store-list-item)
        (zanf-org-refile-find-heading target)
        (insert "\n")
        (insert zanv-org-refile-last-stored-list-item)))


    ;; Since 'org-agenda-kill' doesn't save the file after, make it do so.
    (defun zanf-org-agenda-kill ()
      (interactive)
      (org-agenda-kill)
      (org-save-all-org-buffers))


    ;; Same for 'org-agenda-refile'.
    (defun zanf-org-agenda-refile ()
      (interactive)
      (org-agenda-refile)
      (org-save-all-org-buffers))


    ;; Same for 'org-agenda-add-note'.
    (defun zanf-org-agenda-add-note ()
      (interactive)
      (org-agenda-add-note)
      (org-save-all-org-buffers))


    ;; Make 'org-agenda-quit' close all org-agenda files.
    (defun zanf-org-agenda-quit ()
      (interactive)
      (org-agenda-quit)
      (org-save-all-org-buffers)
      (dolist (filename (org-files-list))
        (let ((buffer (find-buffer-visiting filename)))
  	(when buffer
  	  (kill-buffer buffer)))))


  ;;; Functions for using project-specific org-agenda files.

    (defvar zanv-project-agenda-file-names '("tasks.org")
      "A list containing possible project agenda file names.")

    (defvar zanv-project-agenda-file-locations '("doc")
      "A list containing possible agenda file locations.

  These must be either absolute paths or relative to the project root.")

    (defun zanf-project-agenda--create-agenda (project)
      "Create a project agenda file in the root directory.

  Uses the first name in 'zanv-project-agenda-file-names'.")

    (defun zanf-project-agenda--find-agenda (project)
      "Return the agenda file for the project."
      (let* ((root (project-root project))
  	   (dirs (cons root zanv-project-agenda-file-locations))
  	   (dirs-abs (mapcar
  		      (lambda (dir) (expand-file-name dir root)) dirs)))
        (catch 'found
  	(dolist (file-name zanv-project-agenda-file-names)
  	  (dolist (dir dirs-abs)
  	    (let ((path (expand-file-name file-name dir)))
  	      (when (file-exists-p path)
  		(throw 'found path))))))))

    (defun zanf-project-agenda--create (project)
      "Creates an agenda file for the project and returns the file path.

  Uses the first element from 'zanv-project-agenda-file-name' for the file name 
  and creates it in the project root."
      (let ((filename (expand-file-name (car zanv-project-agenda-file-names)
  				      (project-root project))))
        (write-region "" nil filename nil nil nil 'excl)
        filename))

    (defun zanf-set-gtd-capture-templates ()
      "Set 'org-capture-templates' for the gtd file.

  Adds all the dynamically generated templates."
      (setq org-capture-templates
  	  (append
  	   zanv-org-capture-templates-static
  	   (zanf-dynamic-capture-templates zanv-gtd "Static")
  	   (zanf-dynamic-capture-templates zanv-gtd "Dynamic"))))


    (defun zanf-set-project-capture-templates (project)
      "Set 'org-capture-templates' for the given project.

  All the headings in the project agenda file will generate templates."
      (let ((agenda (zanf-project-agenda--find-agenda project)))
        (setq org-capture-templates
  	    (append
  	     (zanf-org-capture-templates--project-default agenda)
  	     (zanf-dynamic-capture-templates agenda)))))

    (defun zanf-org-capture ()
      "A replacement for 'org-capture' that allows choosing the agenda file.

  It prompts the user to choose getween the GTD agenda or the project's."
      (interactive)
      (let* ((project (when (string= "project"
  				   (completing-read
  				    "Which agenda: " '("gtd" "project")))
  		      (project-current t)))
  	   (agenda (if project
  		       (zanf-project-agenda--find-agenda project)
  		     zanv-gtd)))
        (setq org-agenda-files (list agenda))
        (if project
  	  (zanf-set-project-capture-templates project)
  	(zanf-set-gtd-capture-templates))
        (org-capture)))

    (defun zanf-org-capture--from-agenda ()
      "Call 'org-capture' for the current 'org-agenda-files'.

  Still rebuilds all the dynamic capture templates for the given file."
      (interactive)
      (let ((agenda (car org-agenda-files)))
        (if (file-equal-p agenda zanv-gtd)
  	  (zanf-set-gtd-capture-templates)
  	(zanf-set-project-capture-templates (project-current t)))
        (org-capture))))
#+end_src
** Python-mode functions.
#+begin_src emacs-lisp
  ;; A run python command that allows specifying the interpreter version.
  (defun zanf-run-python--get-interpreter ()
    (completing-read "Which version? (default python3) :"
  		   (directory-files "/usr/bin/" nil "^python.+")
  		   nil t "python3" nil "python3"))

  (defun zanf-run-python ()
    (interactive)
    (run-python (zanf-run-python--get-interpreter) nil t))
#+end_src
** Java-mode functions.
#+begin_src emacs-lisp
  ;; Compiling and running functions.

  (defun zanf-java-compile-all ()
    (interactive)
    (compile "javac *.java" t))

  (setq zanv-java--last-run "")

  (defun zanf-java-run--completing-read ()
    (interactive)
    (setq zanv-java-files '())
    (dolist (file
  	   (directory-files
  	    (file-name-directory (buffer-file-name)) nil ".+\\.java"))
      (push (file-name-sans-extension file) zanv-java-files))
    (completing-read "Which file: " zanv-java-files nil nil zanv-java--last-run))


  (defun zanf-java-run ()
    (interactive)
    (let ((java-file (zanf-java-run--completing-read)))
      (setq zanv-java--last-run java-file)
      (compile (concat "java " java-file) t))
    (other-window 1)
    (goto-char (point-max)))


  (defvar zanv-java-run-project-file--last nil
    "This variable is an alist of projects and their last run file. Does not
  persist over sessions.")


  (defun zanf-java-run-project-file ()
    "Prompts the user the select a '.class' file from the 'bin' directory at the
  project root directory and runs it"
    (interactive)
    (let* ((completion-ignored-extensions nil)
  	 (default-directory (project-root (project-current)))
  	 (bin-dir (concat default-directory "bin/"))
  	 (full-file-path (read-file-name "Run: " bin-dir nil t
  					 zanv-java-run-project-file--last))
  	 (rel-file-path (file-relative-name full-file-path bin-dir))
  	 (class-name (file-name-sans-extension
  		      (replace-regexp-in-string "/" "." rel-file-path))))
      (async-shell-command (format "java -cp %s %s" bin-dir class-name))
      (setq zanv-java-run-project-file--last rel-file-path)))
#+end_src
** C-mode functions.
#+begin_src emacs-lisp
  ;; Custom compiling and running functions.
  (defun zanf-compile-c ()
    "Compile the current C file."
    (interactive)
    (let ((file (file-name-nondirectory buffer-file-name)))
      (compile (concat "gcc " file " -o " (file-name-sans-extension file)))))

  (defun zanf-compile-and-run-c ()
    "Runs the output of the current buffer. Compiles if necessary."
    (interactive)
    (let* ((file (file-name-nondirectory buffer-file-name))
  	 (exe (file-name-sans-extension file)))
      (compile (concat "gcc " file " -o " exe " && ./" exe))))
#+end_src
** Zan-snippet functions.
#+begin_src emacs-lisp
  (when (eq zanc-config-level :full-config)
    ;; The snippet inserting function, helpers, and variables. It uses a directory
    ;; of text files where each file contains an insertable snippet. They may
    ;; contain fields to be replaced at the time of insertion. In the text file,
    ;; these fields should begin and end with 'zanv-snippet-placeholder-delimiter'
    ;; and are grouped by the name within these delimiters. Each group of fields
    ;; with the same name will be replaced by the same string which the user is
    ;; prompted to give at time of insertion. Thus the user will be prompted once to
    ;; supply a new string for "~NAME~" (supposing the delimiter is "~") and all
    ;; instances of "~NAME~" will become the new string.

    ;; TODO - I would like to add a 'capture-snippet' function that takes a region or
    ;; the whole buffer and make a new snippet file. Also a function that changes the
    ;; delimiter and replaces it properly in all snippet files.
    ;;
    ;; TODO - Make 'zanf-snippet' and the system-wide snippet system use the same
    ;; files.



    (defun zanf-snippet--indent-line ()
      (interactive)
      (let ((pstart (point)))
        (indent-according-to-mode t)
        (- (point) pstart)))

    (defun zanf-snippet--indent-all ()
      (interactive)
      (goto-char zanv-snippet--start)
      (while (<= (point) zanv-snippet--end)
        (let ((shift (zanf-snippet--indent-line)))
  	(setq zanv-snippet--end (+ zanv-snippet--end shift))
  	(setq zanv-snippet--start (+ zanv-snippet--start shift)))
        (next-line 1)))

    (defun zanf-snippet--choose-snippet ()
      (concat
       zanv-snippet-dir
       (completing-read
        "Which snippet? "
        (remove
         "." (remove
  	    ".."
  	    (directory-files zanv-snippet-dir))))))

    (defun zanf-snippet--replace-placeholder-get-input (placeholder)
      (let ((affix-length (length zanv-snippet-placeholder-delimiter)))
        (read-string
         (concat
  	(substring placeholder affix-length (* affix-length -1))
        ": "))))

  (defun zanf-snippet--replace-placeholder (placeholder input)
    (goto-char zanv-snippet--start)
    (when (search-forward placeholder zanv-snippet--end t)
      (replace-match input)
      (setq zanv-snippet--end (+ zanv-snippet--end (- (length input) (length placeholder))))
      (zanf-snippet--replace-placeholder
       placeholder
       input)))

  (defun zanf-snippet--has-next-placeholder ()
    (goto-char zanv-snippet--start)
    (if (re-search-forward
         (concat zanv-snippet-placeholder-delimiter
  	       "[^" zanv-snippet-placeholder-delimiter "]*" zanv-snippet-placeholder-delimiter)
         zanv-snippet--end t) t nil))

  (defun zanf-snippet-insert-at-point ()
    (interactive)
    (setq zanv-snippet--start (point))
    (when (= (point) (+ 1 (buffer-size)))
      (insert "\n")
      (goto-char zanv-snippet--start))
    (let* ((snip (zanf-snippet--choose-snippet))
  	 (length (nth 1 (insert-file-contents snip))))
      (setq zanv-snippet--end (+ zanv-snippet--start length))
      (zanf-snippet--indent-all)
      (while (zanf-snippet--has-next-placeholder)
        (let* ((placeholder (match-string 0))
  	     (input (zanf-snippet--replace-placeholder-get-input placeholder)))
  	(zanf-snippet--replace-placeholder placeholder input))))
    (goto-char zanv-snippet--end)))
#+end_src
** Macros for keybindings.
No longer used as use-package fulfills this need. But still interesting.
#+begin_src emacs-lisp
  ;;; A macro for adding keybindings to modes via mode hooks.
  (defmacro zanm-keybindings-for-mode (mode mode-map kbd-commands)
    "Define a function to set keybindings for a major mode and add it to the mode's hook.

  MODE is the mode symbol (e.g., 'java-mode).
  MODE-MAP is the keymap variable (e.g., `java-mode-map`).
  KBD-COMMANDS is a list of keybinding-command pairs. (e.g. ((\"C-c c\" 'some-function)))

  Each keybinding is applied using `keymap-set` when the major mode is activated.
  The generated function is named `zanf-keybindings-MODE` and is automatically
  added to `MODE-hook`."
    (let ((function-symbol (intern (format "zanf-keybindings-%s" mode)))
  	(hook-symbol (intern (format "%s-hook" mode))))
      `(progn
         (defun ,function-symbol ()
  	 (dolist (kbd-command ',kbd-commands)
  	   (keymap-set ,mode-map (car kbd-command) (cadr kbd-command))))
         (add-hook ',hook-symbol #',function-symbol))))


  (defmacro zanm-keybindings-for-multiple-modes (modes-and-maps kbd-commands)
    "Apply the same keybindings to multiple major modes using `zanm-keybindings-for-mode`.

  MODES-AND-MAPS is an alist mapping the mode to the mode-map.
    e.g. ((java-mode . java-mode-map) (java-ts-mode . java-ts-mode-map))
  KBD-COMMANDS is a list of keybinding-command pairs. (e.g. ((\"C-c c\" 'some-function)))"
    `(progn
       ,@(mapcar (lambda (mode-and-map)
  		 `(zanm-keybindings-for-mode
  		   ,(car mode-and-map) ,(cdr mode-and-map) ,kbd-commands))
  		 modes-and-maps)))
#+end_src
* User Variable Definitions
** Set the 'sync' directory and subdirectories (full-config).
#+begin_src emacs-lisp
  (when (eq zanc-config-level :full-config)
    (setq zanv-sync-dir "~/sync/")
    (setq zanv-gtd (concat zanv-sync-dir "gtd/gtd.org"))
    (setq zanv-emacs-dat-dir (concat zanv-sync-dir "dat/emacs/"))
    (setq zanv-texts-dir (concat zanv-sync-dir "texts/"))
    (setq zanv-pricelists-dir (concat zanv-sync-dir "dat/price-lists/"))
    (setq zanv-snippet-dir (concat zanv-emacs-dat-dir "snippets/"))
    (setq zanv-snippet-placeholder-delimiter "~"))
#+end_src
** Set the synced bookmarks file (full-config).
#+begin_src emacs-lisp
  (when (eq zanc-config-level :full-config)
    (setq bookmark-default-file (concat zanv-emacs-dat-dir "bookmarks")))
#+end_src
** Set custom display-buffer-alist variable.
#+begin_src emacs-lisp
  ;; A variable to store my custom version.
  (setq zanv-user-display-buffer-alist
        '(("\\*info\\*"
  	 (display-buffer-in-side-window)
  	 (side . right)
  	 (slot . 0)
  	 (window-width . 80)
  	 (window-height . 0.7)
  	 (window-parameters . ((no-delete-other-windows . t))))
  	("\\*Help\\*"
  	 (display-buffer-in-side-window)
  	 (side . right)
  	 (slot . 1)
  	 (window-width . 80)
  	 (window-height . 0.3)
  	 (window-parameters . ((no-delete-other-windows . t))))
  	("\\*Outline.*\\.pdf\\*"
  	 (display-buffer-in-side-window)
  	 (side . right)
  	 (slot . -1)
  	 (window-width . 80)
  	 (window-height . 0.3)
  	 (window-parameters . ((no-delete-other-windows . t))))
  	("\\*eshell\\*"
  	 (display-buffer-in-side-window)
  	 (side . bottom)
  	 (slot . 0)
  	 (window-width . 0.5)
  	 (window-height . 0.3)
  	 (window-parameters . ((no-delete-other-windows . t))))
  	("\\*Org Agenda\\*"
  	 (display-buffer-in-side-window)
  	 (side . bottom)
  	 (slot . 1)
  	 (window-width . 0.5)
  	 (window-height . 0.3)
  	 (window-parameters . ((no-delete-other-windows . t))))
  	("\\*Async Shell Command\\*"
  	 (display-buffer-in-side-window)
  	 (side . right)
  	 (slot . -1)
  	 (window-width . 80)
  	 (window-height . 0.7)
  	 (window-parameters . ((no-delete-other-windows . t))))
  	("\\*compilation\\*"
  	 (display-buffer-in-side-window)
  	 (side . right)
  	 (slot . -1)
  	 (window-width . 80)
  	 (window-height . 0.7)
  	 (window-parameters . ((no-delete-other-windows . t))))
  	("\\*org-roam\\*"
  	 (display-buffer-in-side-window)
  	 (side . right)
  	 (slot . -1)
  	 (window-width . 80)
  	 (window-height . 0.3)
  	 (window-parameters . ((no-delete-other-windows . t))))))
#+end_src
** Org-capture templates.
#+begin_src emacs-lisp
  (when (eq zanc-config-level :full-config)
    (setq zanv-org-capture-templates-static
  	`(("t" "Task Lists")
  	  ,(zanf-gen-org-capture-template "a" "Anytime" zanv-gtd "t")
  	  ,(zanf-gen-org-capture-template "d" "Daytime" zanv-gtd "t")
  	  ,(zanf-gen-org-capture-template "e" "Evening" zanv-gtd "t")
  	  ,(zanf-gen-org-capture-template "w" "Weekend" zanv-gtd "t")
  	  ,(zanf-gen-org-capture-template "t" "Waiting" zanv-gtd "t" nil t)

  	  ,(zanf-gen-org-capture-template "s" "Someday" zanv-gtd)
  	  ("k" "Tickler" entry (file+olp zanv-gtd "Tickler")
  	   "* TODO %? %^g\nSCHEDULED: %^t")

  	  ("p" "Projects")

  	  ("w" "Work Lists")
  	  ("wv" "Potential Visits")
  	  ,(zanf-gen-org-capture-template
  	    "e" "Edmonton" zanv-gtd "wv" '("Static" "Visits"))
  	  ,(zanf-gen-org-capture-template
  	    "c" "Calgary" zanv-gtd "wv" '("Static" "Visits"))
  	  ,(zanf-gen-org-capture-template
  	    "v" "Vancouver" zanv-gtd "wv" '("Static" "Visits"))
  	  ,(zanf-gen-org-capture-template
  	    "V" "Victoria" zanv-gtd "wv" '("Static" "Visits"))
  	  ,(zanf-gen-org-capture-template
  	    "i" "Interior" zanv-gtd "wv" '("Static" "Visits"))
  	  ,(zanf-gen-org-capture-template
  	    "s" "Saskatoon" zanv-gtd "wv" '("Static" "Visits"))
  	  ,(zanf-gen-org-capture-template
  	    "r" "Regina" zanv-gtd "wv" '("Static" "Visits"))
  	  ,(zanf-gen-org-capture-template
  	    "w" "Winnipeg" zanv-gtd "wv" '("Static" "Visits"))

  	  ("wp" "Prospects")
  	  ,(zanf-gen-org-capture-template
  	    "e" "Edmonton" zanv-gtd "wp" '("Static" "Prospects"))
  	  ,(zanf-gen-org-capture-template
  	    "c" "Calgary" zanv-gtd "wp" '("Static" "Prospects"))
  	  ,(zanf-gen-org-capture-template
  	    "v" "Vancouver" zanv-gtd "wp" '("Static" "Prospects"))
  	  ,(zanf-gen-org-capture-template
  	    "V" "Victoria" zanv-gtd "wp" '("Static" "Prospects"))
  	  ,(zanf-gen-org-capture-template
  	    "i" "Interior" zanv-gtd "wp" '("Static" "Prospects"))
  	  ,(zanf-gen-org-capture-template
  	    "s" "Saskatoon" zanv-gtd "wp" '("Static" "Prospects"))
  	  ,(zanf-gen-org-capture-template
  	    "r" "Regina" zanv-gtd "wp" '("Static" "Prospects"))
  	  ,(zanf-gen-org-capture-template
  	    "w" "Winnipeg" zanv-gtd "wp" '("Static" "Prospects"))

  	  ,(zanf-gen-org-capture-template
  	    "e" "Expense Reminders" zanv-gtd "w" '("Static") t)
  	  ,(zanf-gen-org-capture-template
  	    "n" "Name on Accounts" zanv-gtd "w" '("Static"))

  	  ("l" "Other Lists")

  	  ("n" "New Project or List")
  	  ("np" "Project" entry (file+olp zanv-gtd "Projects")
  	   "* %^{Project name}^p%^{Capture keys} :%^{tags}:")
  	  ("nw" "Work List" entry (file+olp zanv-gtd "Dynamic")
  	   "* %^{List name}^w%^{Capture keys} :%^{tags}:")
  	  ("nl" "Other List" entry (file+olp zanv-gtd "Dynamic")
  	   "* %^{List name}^l%^{Capture keys} :%^{tags}:"))))
#+end_src
* Built-in Configurations
** Keybindings.
#+begin_src emacs-lisp
  (use-package emacs
    :init
    (define-prefix-command 'zan-global-keymap)
    :bind-keymap
    (("C-c k" . zan-global-keymap))
    :bind
    (("C-x C-c" . save-buffers-kill-emacs)
     ("C-x r m" . zanf-bookmark-set)
     ("C-x p d" . zanf-project-dired)
     ("C-x p R" . zanf-project-run)
     :map
     zan-global-keymap
     ("s" . zanf-snippet-insert-at-point)
     ("m" . magit-list-repos)
     ("f" . zanf-insert-filename)
     ("w" . window-toggle-side-windows)
     ("b" . zanf-toggle-user-display-buffer-alist)
     :map
     prog-mode-map
     ("C-c n" . flymake-goto-next-error)
     ("C-c c" . comment-region)
     ("C-c u" . uncomment-region)))

  ;; For full-config only bindings.
  (when (eq zanc-config-level :full-config)
    (use-package emacs
      :bind
      (:map
       zan-global-keymap
       ("t" . zanf-open-text)
       ("p" . zanf-open-pricelist))))
#+end_src
** Basic UI configurations.
#+begin_src emacs-lisp
  ;; Needed to avoid errors on non-gui compilation.
  (require 'scroll-bar)
  (require 'tool-bar)

  (setq inhibit-startup-message t)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (tooltip-mode -1)
  (setq visible-bell t)
  (setq initial-scratch-message nil)
  (setq column-number-mode t)
  (global-visual-line-mode)

  ;; Make frames maximized by default.
  (add-to-list 'default-frame-alist '(fullscreen . maximized))

  ;; Makes it so horizontal splits are preferred on 2440x1440 res screens.
  (setq split-height-threshold 90)

  ;; Set display line-numbers-mode for all but certain modes.
  (global-display-line-numbers-mode t)
  (dolist (mode '(org-mode-hook
  		eshell-mode-hook
  		pdf-view-mode-hook
  		shell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode -1))))
#+end_src
** Window configurations.
#+begin_src emacs-lisp
  (setq display-buffer-alist zanv-user-display-buffer-alist)
  (setq window-sides-vertical t)
#+end_src
** Autosave and backup file behaviour.
#+begin_src emacs-lisp
  (setq kill-buffer-delete-auto-save-files t)
  (setq make-backup-files nil)
#+end_src
** Extending authinfo character hiding to more fields.
#+begin_src emacs-lisp
  (setq authinfo-hidden (rx (or "password"
  			      "client-id"
  			      "client-secret"
  			      "refresh-token")))
#+end_src
** Follow symlinks to the real files under version control.
#+begin_src emacs-lisp
  (setq vc-follow-symlinks t)
#+end_src
** Tree-sitter configuration (full-config only due to grammers being stored in 'sync' directory).
#+begin_src emacs-lisp
  (when (eq zanc-config-level :full-config)
    ;; Set the load-path to the grammers directory.
    (setq treesit-extra-load-path `(,(concat zanv-sync-dir "dat/tree-sitter-grammers/")))
    (setq treesit-font-lock-level 4)
    (setq major-mode-remap-alist '((java-mode . java-ts-mode)
  				 (c-mode . c-ts-mode)
  				 (python-mode . python-ts-mode)
  				 (gdscript-mode . gdscript-ts-mode))))
#+end_src
** Set dictionary (full-config).
Plain text word lists to be used with the variable below can be generated at http://app.aspell.net/create/. NOTE: Lines with apostrophes need to be removed from generated word list. Note that this variable needs the path set without using the tilde.
#+begin_src emacs-lisp
  (when (eq zanc-config-level :full-config)
    (setq ispell-alternate-dictionary "/home/zan/sync/dat/emacs/word-list/en_CA.txt"))
#+end_src
** Add example to shortdoc for functions.
#+begin_src emacs-lisp
  (add-hook 'help-fns-describe-function-functions
  	  #'shortdoc-help-fns-examples-function)
#+end_src
** Abbrev-mode configurations (full-config).
#+begin_src emacs-lisp
  (when (eq zanc-config-level :full-config)
    (setq abbrev-suggest t)
    (setq abbrev-file-name (concat zanv-emacs-dat-dir "abbrevs_defs"))
    (setq-default abbrev-mode t))
#+end_src
** Set default printer (full-config).
#+begin_src emacs-lisp
  (when (eq zanc-config-level :full-config)
    (setq lpr-command "lp")
    (setq lpr-add-switches nil))
#+end_src
** Add new project.el root directory markers.
#+begin_src emacs-lisp
  (setq project-vc-extra-root-markers '(".project.el"))
#+end_src

** Dired configurations.
#+begin_src emacs-lisp
  (setq dired-maybe-use-globstar t)
  (setq dired-kill-when-opening-new-dired-buffer t)

  ;; Make no details the default.
  (add-hook 'dired-mode-hook 'dired-hide-details-mode)
#+end_src
** Eshell configurations
#+begin_src emacs-lisp
  (use-package eshell
    :config
    (add-to-list 'eshell-modules-list 'eshell-elecslash)
    (when (eq zanc-config-level :full-config)
      (setq eshell-aliases-file (concat zanv-emacs-dat-dir "eshell/alias")))
    :bind
    (:map zan-global-keymap
  	("e" . eshell)))
#+end_src
** Org-mode
#+begin_src emacs-lisp
  (use-package org
    :config
    (setq org-outline-path-complete-in-steps nil))
#+end_src
** Org-capture configurations (full-config).
#+begin_src emacs-lisp
  (when (eq zanc-config-level :full-config)
    (use-package org-capture
      :config
      (setq org-directory "~/sync/gtd")
      (setq org-agenda-entry-text-maxlines 20)
      (setq org-refile-use-outline-path t)
      (setq org-agenda-files `(,zanv-gtd))
      :bind
      (:map zan-global-keymap
       ("k" . zanf-org-capture))))
#+end_src
** Org-agenda configurations (full-config).
#+begin_src emacs-lisp
  (when (eq zanc-config-level :full-config)
    (use-package org-agenda
      :config
      (setq org-agenda-custom-commands
  	  '(("p" "Project Agenda" tags-todo ""
  	     ((org-agenda-files
  	       (setq org-agenda-files
  		     (list (let ((project (project-current t)))
  			     (or (zanf-project-agenda--find-agenda project)
  				 (zanf-project-agenda--create project))))))))
  	    ("g" "GTD" tags-todo ""
  	     ((org-agenda-files (setq org-agenda-files (list zanv-gtd)))))))
      (setq org-refile-targets '((nil . (:maxlevel . 5))))
      :bind (:map
  	   zan-global-keymap
  	   ("a" . org-agenda)
  	   :map
  	   org-agenda-mode-map
  	   ("k" . zanf-org-capture--from-agenda)
  	   ("C-k" . zanf-org-agenda-kill)
  	   ("C-c C-q" . zanf-org-agenda-refile)
  	   ("z" . zanf-org-agenda-add-note)
  	   ("q" . zanf-org-agenda-quit))))
#+end_src
** Python.
#+begin_src emacs-lisp
  (use-package python
    :if (eq zanc-config-level :full-config)
    :config
    (require 'pyvenv))

  (use-package pyvenv
    :if (eq zanc-config-level :full-config)
    :ensure t
    :config
    (setenv "WORKON_HOME" (concat zanv-sync-dir ".venvs/"))
    :bind
    (:map
     python-mode-map
     ("C-c v" . pyvenv-workon)
     ("C-c p" . zanf-run-python)
     :map
     python-ts-mode-map
     ("C-c v" . pyvenv-workon)
     ("C-c p" . zanf-run-python)))
#+end_src
** Java
#+begin_src emacs-lisp
  (use-package java-mode
    :bind
    (:map
     java-mode-map
     ("C-c c" . zanf-java-compile-all)
     ("C-c r" . zanf-java-run-project-file)
     :map
     java-ts-mode-map
     ("C-c c" . zanf-java-compile-all)
     ("C-c r" . zanf-java-run-project-file)))
#+end_src
** CC Mode
#+begin_src emacs-lisp
  (setq c-default-style '((java-mode . "java")
  			  (awk-mode . "awk")
  			  (other . "stroustrup")))

  (use-package c-mode
    :bind
    (:map
     c-mode-map
     ("C-c c" . zanf-compile-c)
     ("C-c r" . zanf-compile-and-run-c)
     :map
     c-ts-mode-map
     ("C-c c" . zanf-compile-c)
     ("C-c r" . zanf-compile-and-run-c)))
#+end_src
** Electric-pair-mode hooks.
#+begin_src emacs-lisp
  (defvar zanv-epair-mode-hooks
    '(python-mode-hook
      python-ts-mode-hook
      java-mode-hook
      java-ts-mode-hook
      c-mode-hook
      c-ts-mode-hook
      c++-mode-hook
      shell-mode-hook
      sh-mode-hook
      emacs-lisp-mode-hook
      LaTeX-mode-hook
      gdscript-mode-hook
      gdscript-ts-mode-hook))

  (dolist (mode zanv-epair-mode-hooks) (add-hook mode 'electric-pair-local-mode))
#+end_src
** Eglot.
#+begin_src emacs-lisp
  (use-package eglot
    :init
    (define-prefix-command 'zan-eglot-keymap)
    :config
    (add-to-list 'eglot-server-programs
  	       '((gdscript-mode gdscript-ts-mode) . ("localhost" 6005)))
    :bind-keymap
    ("C-c e" . zan-eglot-keymap)
    :bind
    (:map
     zan-eglot-keymap
     ("e" . eglot)
     ("C-e" . eglot-reconnect)
     ("r" . eglot-rename)
     ("f" . eglot-format-buffer)
     ("c" . eglot-code-actions)
     ("x" . eglot-code-action-extract)))
#+end_src
* 3rd Party Package Configurations
** ef-themes
#+begin_src emacs-lisp
  (use-package ef-themes
    :ensure t
    :config
    (load-theme 'ef-trio-dark :no-confirm))
#+end_src
** diminish
#+begin_src emacs-lisp
  (use-package diminish
    :ensure t)
#+end_src
** vertico
#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :init
    (vertico-mode)
    :custom
    (vertico-count 10)
    (vertico-resize nil))
#+end_src
** marginalia
#+begin_src emacs-lisp
  (use-package marginalia
    :ensure t
    :init
    (marginalia-mode))
#+end_src
** consult
#+begin_src emacs-lisp
  (use-package consult
    :ensure t)
#+end_src
** which-key
#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :init
    (which-key-mode)
    (diminish 'which-key-mode)
    (which-key-setup-minibuffer)) ; to help with echo area covering which-key
#+end_src
** corfu
#+begin_src emacs-lisp
  (use-package corfu
    :ensure t
    :init
    (global-corfu-mode)
    (setq corfu-auto t))
#+end_src
** git-gutter
#+begin_src emacs-lisp
  (use-package git-gutter
    :ensure t
    :hook prog-mode
    :config
    (diminish 'git-gutter)
    (setq git-gutter:update-interval 0.02))

  (use-package git-gutter-fringe
    :ensure t
    :config
    (define-fringe-bitmap 'git-gutter-fr:added [224] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:modified [224] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:deleted [128 192 224 240] nil nil 'bottom))
#+end_src
** magit
#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :config
    (setq magit-repository-directories
  	'(("~/" . 1)
  	  ("~/.emacs.d/" . 1)
  	  ("~/sync/" . 4))))
#+end_src
** zeal-at-point (full-config)
#+begin_src emacs-lisp
  (when (eq zanc-config-level :full-config)
    (use-package zeal-at-point
      :ensure t
      :bind
      (:map
       prog-mode-map
       ("C-c z" . zeal-at-point))))
#+end_src
** pdf-tools
#+begin_src emacs-lisp
  (use-package pdf-tools
    :ensure t
    :config (pdf-loader-install))

  (use-package pdf-view-mode
    :bind
    (:map
     pdf-view-mode-map
     ("q" . zanf-pdf-view-quit)
     ("C-c x" . doc-toc-extract-pages)))
#+end_src
** doc-toc
#+begin_src emacs-lisp
  (use-package doc-toc
    :ensure t)
#+end_src
** auctex
#+begin_src emacs-lisp
  (use-package auctex
    :ensure t
    :config
    (setq TeX-auto-save t)
    (setq TeX-parse-self t)
    (setq TeX-electric-math '("$" . "$")))
#+end_src
** ace-window
#+begin_src emacs-lisp
  (use-package ace-window
    :ensure t
    :bind
    ("M-o" . ace-window)
    :custom
    (aw-keys '(?a ?s ?d ?f ?h ?j ?k ?l))
    (aw-scope 'frame))
#+end_src
** embark
#+begin_src emacs-lisp
  (use-package embark
    :ensure t
    :bind
    (("C-." . embark-act)))

  (use-package embark-consult
    :ensure t)
#+end_src
** gdscript-mode
#+begin_src emacs-lisp
  (use-package gdscript-mode
    :ensure t
    :hook ((gdscript-mode . eglot-ensure)
  	 (gdscript-ts-mode . eglot-ensure)))
#+end_src
** org-roam (full-config)
#+begin_src emacs-lisp
  (when (eq zanc-config-level :full-config)
    (use-package org-roam
      :ensure t
      :init
      (define-prefix-command 'zan-org-roam-keymap)
      :config
      (setq org-roam-directory "~/sync/dat/org-roam/")
      (org-roam-db-autosync-mode)
      :bind-keymap
      ("C-c r" . zan-org-roam-keymap)
      :bind
      (:map
       zan-org-roam-keymap
       ("f" . org-roam-node-find)
       ("i" . org-roam-node-insert)
       ("b" . org-roam-buffer-toggle))))
#+end_src
** org-pdf-tools
#+begin_src emacs-lisp
  (use-package org-pdftools
    :ensure t
    :hook (org-mode . org-pdftools-setup-link))
#+end_src
** org-journal (full-config)
#+begin_src emacs-lisp
  (when (eq zanc-config-level :full-config)
    (use-package org-journal
      :ensure t
      :config
      (setq org-journal-dir "~/sync/dat/org-journal/")
      (setq org-journal-file-type 'monthly)
      :bind
      (:map
       zan-global-keymap
       ("j" . org-journal-new-entry))))
#+end_src
** gptel
#+begin_src emacs-lisp
  (when (eq zanc-config-level :full-config)
    (use-package gptel
      :ensure t
      :init
      (define-prefix-command 'zan-gptel-keymap)
      :bind-keymap
      ("C-c g" . zan-gptel-keymap)
      :bind
      (:map
       zan-gptel-keymap
       ("g" . gptel)
       ("s" . gptel-send))))
#+end_src
** avy
#+begin_src emacs-lisp
  (use-package avy
    :ensure t
    :demand t
    :bind
    ("C-;" . avy-goto-char-2))
#+end_src
